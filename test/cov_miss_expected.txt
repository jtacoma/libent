alloc.c:15:		return -1;
alloc.c:43:		errno = ENOMEM;
alloc.c:44:		return -1;
model.c:90:		return NULL;
model.c:98:		ent_alloc ((void**)&newname, 0);
model.c:99:		return NULL;
model.c:104:		ent_alloc ((void**)&newname, 0);
model.c:105:		ent_table_decref (t);
model.c:106:		return NULL;
processor.c:88:		return -1;
processor.c:95:		return -1;
processor.c:150:		return -1;
processor.c:161:		return -1;
processor.c:169:ent_processor_set_function (
processor.c:174:	if (! (p && function))
processor.c:176:		return -1;
processor.c:179:	p->func = function;
processor.c:180:	p->func_arg = arg;
processor.c:181:	return 0;
processor.c:205:		return NULL;
processor.c:227:		return (struct column_info) {0};
processor.c:236:		return (struct column_info) {0};
session.c:42:		return NULL;
session.c:49:		return NULL;
session.c:57:		free (s);
session.c:58:		return NULL;
session.c:65:		ent_array_free (s->inserts);
session.c:66:		free (s);
session.c:67:		return NULL;
session.c:178:		return -1;
session.c:185:		ent_table_decref (buffer);
session.c:186:		return -1;
session.c:207:		return -1;
session.c:215:		return -1;
session.c:233:		return -1;
session.c:276:ent_session_column_get (
session.c:281:	return ent_session_column_ref (s, table, column);
session.c:290:		return -1;
session.c:301:			return -1;
table.c:36:			free (t);
table.c:91:		*width = 0;
table.c:92:		return NULL;
table.c:112:ent_table_has_column_name (
table.c:116:	if (! (t && name))
table.c:118:		return false;
table.c:121:	size_t columns_len = ent_array_len (t->columns);
table.c:122:	struct column_info * columns = ent_array_ref (t->columns);
table.c:123:	for (size_t i = 0; i < columns_len; ++i)
table.c:125:		if (strcmp (columns[i].name, name) == 0)
table.c:127:			return true;
table.c:131:	return false;
table.c:165:		return NULL;
table.c:175:		ent_array_set_len (t->columns, columns_len);
table.c:178:		return NULL; // out of memory
table.c:189:		free (columns[columns_len].name);
table.c:190:		ent_array_set_len (t->columns, columns_len);
table.c:191:		return NULL; // out of memory
table.c:196:		ent_array_free (columns[columns_len].array);
table.c:197:		free (columns[columns_len].name);
table.c:198:		return NULL; // out of memory
table.c:261:			for (size_t k = 0; k < i; ++k)
table.c:263:				ent_array_free (dst_columns[i].array);
table.c:266:			ent_array_free (new_columns);
table.c:267:			ent_rlist_free (keep);
table.c:268:			return -1;
table.c:280:			for (size_t k = 0; k < i; ++k)
table.c:282:				ent_array_free (dst_columns[i].array);
table.c:285:			ent_array_free (new_columns);
table.c:286:			ent_rlist_free (keep);
table.c:287:			return -1;
table.c:313:		return -1;
table.c:324:			return -1;
