alloc.c:15:		return -1;
alloc.c:43:		errno = ENOMEM;
alloc.c:44:		return -1;
array_test.c:75:		assert_true (errno == 0);
array_test.c:95:		assert_true (errno == 0);
array_test.c:131:		assert_true (errno == 0);
array_test.c:148:		assert_true (errno == 0);
array_test.c:187:		assert_true (errno == 0);
main.c:8:		fprintf (stderr, "%s:%d: %s\n",
main.c:10:		exit (1);
model.c:90:		return NULL;
model.c:98:		ent_alloc ((void**)&newname, 0);
model.c:99:		return NULL;
model.c:104:		ent_alloc ((void**)&newname, 0);
model.c:105:		ent_table_decref (t);
model.c:106:		return NULL;
processor.c:44:ent_processor_cpy_alloc (
processor.c:47:	struct ent_processor * dst = ent_processor_alloc (src->model);
processor.c:49:	if (dst)
processor.c:51:		*dst = *src;
processor.c:52:		dst->tables = ent_array_cpy_alloc (dst->tables);
processor.c:54:		if (!dst->tables)
processor.c:56:			ent_alloc ((void**)&dst, 0);
processor.c:57:			return NULL;
processor.c:60:		dst->columns = ent_array_cpy_alloc (dst->columns);
processor.c:62:		if (!dst->columns)
processor.c:64:			ent_array_free (dst->tables);
processor.c:65:			ent_alloc ((void**)&dst, 0);
processor.c:66:			return NULL;
processor.c:70:	return dst;
processor.c:118:		return -1;
processor.c:125:		return -1;
processor.c:180:		return -1;
processor.c:191:		return -1;
processor.c:199:ent_processor_set_function (
processor.c:204:	if (! (p && function))
processor.c:206:		return -1;
processor.c:209:	p->func = function;
processor.c:210:	p->func_arg = arg;
processor.c:211:	return 0;
processor.c:235:		return NULL;
processor.c:257:		return (struct column_info) {0};
processor.c:266:		return (struct column_info) {0};
rlist.c:67:		return NULL;
rlist.c:107:			return -1; // out of memory
rlist.c:128:		return -1;
session.c:42:		return NULL;
session.c:49:		return NULL;
session.c:57:		free (s);
session.c:58:		return NULL;
session.c:65:		ent_array_free (s->inserts);
session.c:66:		free (s);
session.c:67:		return NULL;
session.c:178:		return -1;
session.c:185:		ent_table_decref (buffer);
session.c:186:		return -1;
session.c:207:		return -1;
session.c:215:		return -1;
session.c:233:		return -1;
session.c:276:ent_session_column_get (
session.c:281:	return ent_session_column_ref (s, table, column);
session.c:290:		return -1;
session.c:301:			return -1;
table.c:36:			free (t);
table.c:91:		*width = 0;
table.c:92:		return NULL;
table.c:112:ent_table_has_column_name (
table.c:116:	if (! (t && name))
table.c:118:		return false;
table.c:121:	size_t columns_len = ent_array_len (t->columns);
table.c:122:	struct column_info * columns = ent_array_ref (t->columns);
table.c:123:	for (size_t i = 0; i < columns_len; ++i)
table.c:125:		if (strcmp (columns[i].name, name) == 0)
table.c:127:			return true;
table.c:131:	return false;
table.c:165:		return NULL;
table.c:175:		ent_array_set_len (t->columns, columns_len);
table.c:178:		return NULL; // out of memory
table.c:189:		free (columns[columns_len].name);
table.c:190:		ent_array_set_len (t->columns, columns_len);
table.c:191:		return NULL; // out of memory
table.c:196:		ent_array_free (columns[columns_len].array);
table.c:197:		free (columns[columns_len].name);
table.c:198:		return NULL; // out of memory
table.c:261:			for (size_t k = 0; k < i; ++k)
table.c:263:				ent_array_free (dst_columns[i].array);
table.c:266:			ent_array_free (new_columns);
table.c:267:			ent_rlist_free (keep);
table.c:268:			return -1;
table.c:280:			for (size_t k = 0; k < i; ++k)
table.c:282:				ent_array_free (dst_columns[i].array);
table.c:285:			ent_array_free (new_columns);
table.c:286:			ent_rlist_free (keep);
table.c:287:			return -1;
table.c:313:		return -1;
table.c:324:			return -1;
alloc.c:15:		return -1;
alloc.c:43:		errno = ENOMEM;
alloc.c:44:		return -1;
main.c:8:		fprintf (stderr, "%s:%d: %s\n",
main.c:10:		exit (1);
model.c:90:		return NULL;
model.c:98:		ent_alloc ((void**)&newname, 0);
model.c:99:		return NULL;
model.c:104:		ent_alloc ((void**)&newname, 0);
model.c:105:		ent_table_decref (t);
model.c:106:		return NULL;
processor.c:44:ent_processor_cpy_alloc (
processor.c:47:	struct ent_processor * dst = ent_processor_alloc (src->model);
processor.c:49:	if (dst)
processor.c:51:		*dst = *src;
processor.c:52:		dst->tables = ent_array_cpy_alloc (dst->tables);
processor.c:54:		if (!dst->tables)
processor.c:56:			ent_alloc ((void**)&dst, 0);
processor.c:57:			return NULL;
processor.c:60:		dst->columns = ent_array_cpy_alloc (dst->columns);
processor.c:62:		if (!dst->columns)
processor.c:64:			ent_array_free (dst->tables);
processor.c:65:			ent_alloc ((void**)&dst, 0);
processor.c:66:			return NULL;
processor.c:70:	return dst;
processor.c:118:		return -1;
processor.c:125:		return -1;
processor.c:180:		return -1;
processor.c:191:		return -1;
processor.c:199:ent_processor_set_function (
processor.c:204:	if (! (p && function))
processor.c:206:		return -1;
processor.c:209:	p->func = function;
processor.c:210:	p->func_arg = arg;
processor.c:211:	return 0;
processor.c:235:		return NULL;
processor.c:257:		return (struct column_info) {0};
processor.c:266:		return (struct column_info) {0};
rlist.c:67:		return NULL;
rlist.c:107:			return -1; // out of memory
rlist.c:128:		return -1;
session.c:42:		return NULL;
session.c:49:		return NULL;
session.c:57:		free (s);
session.c:58:		return NULL;
session.c:65:		ent_array_free (s->inserts);
session.c:66:		free (s);
session.c:67:		return NULL;
session.c:178:		return -1;
session.c:185:		ent_table_decref (buffer);
session.c:186:		return -1;
session.c:207:		return -1;
session.c:215:		return -1;
session.c:233:		return -1;
session.c:276:ent_session_column_get (
session.c:281:	return ent_session_column_ref (s, table, column);
session.c:290:		return -1;
session.c:301:			return -1;
table.c:36:			free (t);
table.c:91:		*width = 0;
table.c:92:		return NULL;
table.c:112:ent_table_has_column_name (
table.c:116:	if (! (t && name))
table.c:118:		return false;
table.c:121:	size_t columns_len = ent_array_len (t->columns);
table.c:122:	struct column_info * columns = ent_array_ref (t->columns);
table.c:123:	for (size_t i = 0; i < columns_len; ++i)
table.c:125:		if (strcmp (columns[i].name, name) == 0)
table.c:127:			return true;
table.c:131:	return false;
table.c:165:		return NULL;
table.c:175:		ent_array_set_len (t->columns, columns_len);
table.c:178:		return NULL; // out of memory
table.c:189:		free (columns[columns_len].name);
table.c:190:		ent_array_set_len (t->columns, columns_len);
table.c:191:		return NULL; // out of memory
table.c:196:		ent_array_free (columns[columns_len].array);
table.c:197:		free (columns[columns_len].name);
table.c:198:		return NULL; // out of memory
table.c:261:			for (size_t k = 0; k < i; ++k)
table.c:263:				ent_array_free (dst_columns[i].array);
table.c:266:			ent_array_free (new_columns);
table.c:267:			ent_rlist_free (keep);
table.c:268:			return -1;
table.c:280:			for (size_t k = 0; k < i; ++k)
table.c:282:				ent_array_free (dst_columns[i].array);
table.c:285:			ent_array_free (new_columns);
table.c:286:			ent_rlist_free (keep);
table.c:287:			return -1;
table.c:313:		return -1;
table.c:324:			return -1;
