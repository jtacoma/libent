libent
======

Status: **Alpha**

This is (or will be) a C implementation of, and therefore buzzword compatible
with, the following:

 * the "entities and components" pattern common in modern game programming
   engines.  Entity identifiers are indices into contiguous buffers of component
   data.

 * an embedded in-memory columnar data store providing atomicity, consistency,
   and isolation.  Column data is accessed directly in memory.  Transactions
   will be implemented with per-column mutexes.

 * data oriented programming.  Well, actually just data locality for now, but
   given the scope for optimization once the basic functionality is working...
   very likely in other ways too.

 * Vulkan-compatible.  Or, well, it probably will be...

Etymologically, "libent" is third-person plural present active subjunctive of
libo, to "taste", "make a libation", "spill", or "graze".  Also in Tagalog,
"thousand".  Some day these meanings will all come together in a wonderful
metaphor about this library.

Version 1.0 Roadmap
-------------------

 * Fine-grained (column-scoped) locks will let the same tables be operated on
   by many processors simultaneously sharing both read & write access.

 * Integration with OpenGL 2.0 (and/or later) shaders.

 * Binding to at least one scripting language (Lua, Python, and SQL are
   candidates).

Version 0.1 POC Roadmap
-----------------------

 * Support strings and floating point numbers.  It's ok to support only one
   precision for floating-point numbers.  It's also ok to assume all strings are
   UTF-8.

 * Support simple insert, select, update, and delete operations.

 * Proof-of-concept integration with OpenGL 2.0 (and/or later) vertex shaders.

Coding Style
------------

Artistic Style (astyle) is used with the following options:

    --style=allman
    --add-one-line-brackets
    --indent=tab
    --pad-oper
    --pad-header
    --unpad-paren
    --pad-first-paren-out

Memory ownership is never passed through function parameters; only through
pointers returned from allocation functions, identified by the "alloc" suffix.
For each allocation function there is a correponding "free" function.

Out-of-memory conditions are handled in such a way that data structures are left
in a coherent state and an error value is returned.  For functions returning
pointers, a return value of NULL indicates an error.  For functions returning
int, a return value of -1 indicates an error.  For simple query functions that
return data, a default (zero) value is returned.

In any case, errno is always set to ENOMEM in case of out-of-memory conditions
and to EINVAL for invalid arguments.

Never (ever) cast away const.

License
-------

To be decided.  Initially this library will only be used, embedded, inside my
own hobby projects.
